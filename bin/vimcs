#!/bin/sh
# vimcsearch
# Created: Fri Apr 18 10:48:35 SGT 2014
#set -x

usage() {
	echo "usage: vimcsearch [-e <pattern>|-g] ...
  Options:
    -e <pattern>
        exclude files matching <pattern>
    -f <regex>
        include only files matching <regex>
    -g
        exlude files matching '/mock|_test.go'
    -h
        Help
    -i
        Case sensitive
    -v
	Verbose"
}

curr_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$curr_branch" != 'master' ]; then
	figlet "not on master branch" >&2
fi

exclude_regex=
i=
file_regex=
opt_verbose=
while getopts e:f:ghilv opt
do
  case "$opt" in
    e) exclude_regex=$OPTARG;;
    f) file_regex="-f \"$OPTARG\"";;
    g) exclude_regex='(mock[a-z_]*\.go:|_test\.go:)';;
    h) usage; exit ;;
    l) : ;; # ignore "-l" for "vimcaller -l"
    i) i=-i;;
    v) opt_verbose=1;;
    \?) echo Unknown option ; exit;;
  esac
done
shift $(($OPTIND -1))

qf=/tmp/vimsearch.quickfix.txt.$$
trap "rm -f $qf" EXIT
me=$(basename $0)

vimcs_cmd='csearch -e "_test.go" -f $(pwd)'
cmd=cs
case "$me" in
	# filename.go:47:  foo bar = baz
	vimecs|cse|ecs)  # cse = csearch equal - 'needle = value'
		#perl -pe 's/.*:.*?([^ ]+) =.*/$1/'
		# get the chunk just before '=':
		regx=$(cs "$@"|gsed -e 's/  *=.*//' -e 's/.*[ 	]//'|tr '\n' '|'|sed -e 's/|$//')
		#echo "regx is $regx"
		set -- "$regx"
		cmd=$vimcs_cmd
		;;
	*qcsearch)  cmd=qcsearch ;; # Obsolete qcsearch?
	*csearcd)  cmd=csearchd ;;
	*csearchm)  cmd='csearch -e "_test.go"';;

	*csd)  cmd='csearch -f $(pwd)' ;;
	*csm)  cmd='csearch -e "_test.go|mock"';;
	*csmd) cmd='csearch -e "_test.go|mock" -f $(pwd)' ;;

	vimcaller) cmd="csearch -e '_test.go' -f $(pwd)"
		func=$1
		#set -- '([.(]|, |= |if |return )'"$func"'[(,]'
		set -- '([.(]|, |= |if !?|(return|go) |^[ \t]*)'"$func"'[(,]'
		#exit 1

		;;
esac

#if [ -n "$exclude_regex" ]; then
#	$cmd $i -n "$@" | grep -E -v "$exclude_regex" > $qf
#else
#	$cmd $i -n "$@" > $qf
#fi
if [ -n "$exclude_regex" ]; then
	eval "$cmd $file_regex $i -n \"$@\"" | grep -E -v "$exclude_regex" > $qf
else
	if [ -n "$opt_verbose" ]; then
		echo "$cmd $file_regex $i -n \"$@\"" >&2
	fi
	eval "$cmd $file_regex $i -n \"$@\"" > $qf
	#eval "$cmd $file_regex $i -n $@" > $qf
	#$cmd $file_regex $i -n $@ > $qf
fi

if [ ! -s $qf ]; then
	exit 1
fi

for regex; do :; done # last arg is regex
# in vim magic mode '=' need to be escaped to literally match it
#echo "A REGEX '$regex'"
regex=$(echo "$regex"|sed -e 's,/,\\/,g' -e 's/=/\\=/g')
#echo "B REGEX '$regex'"
vi -R -c "/\\v$regex" -c "match quickfixregex /\\v$regex/" -q $qf
